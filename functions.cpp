/* Описание основных функций, принимающих участие в работе программы */

#include <time.h>
#include <stdio.h>
#include <iostream>
#include "definitions.h"
#include "my_math.h"
#include "functions.h"

int GetXRange(double a, double b, double h) {
	// Цель: Получение количества точек Х заданной дискретизации на полуинтервале [a, b)
	// Исходные данные:
	//		a – левая граница полуинтервала
	//		b - правая граница полуинтервала
	//		h - шаг дискретизации
	// Результат: функция возвращает целое значение, соответствующее количеству точек Х
	// заданной дискретизации на полуинтервале [a, b)
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) Объявляется переменная-счетчик int range и инициализируется нулевым значением
	* 2) Переменная а увеличивается на шаг дискретизации h пока a < b
	* 3) В каждой итерации счетчик увеличивает значение на 1
	* 4) Возвращается значение счетчика
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	int range = 0;
	while (a < b) {
		range++;
		a += h;
	}
	return range;
}

double Fx(double x) {
	// Цель: Вычисление значения функции f(x), заданной системой из трех уравнений
	// Исходные данные:
	//		х – значение аргумента функции
	// Результат: функция возвращает вещественное значение, соответствующее значению функции f(x)
	// заданной дискретизации на полуинтервале [a, b)
	// Вызываемые модули: 
	//1) <iostream>
	//2) "my_math.h"
	/* Описание алгоритма :
	* 1) Объявляется переменная-счетчик int range и инициализируется нулевым значением
	* 2) Переменная а увеличивается на шаг дискретизации h пока a < b
	* 3) В каждой итерации счетчик увеличивает значение на 1
	* 4) Возвращается значение счетчика
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/*********************************************************************************************/
	double x2 = PwrNat(x, 2);
	int rule = x2 < 1? 1: x2 <= 2? 2: 3;
	switch (rule) {
	case 1: return x2 + Sqrt2(Abs(x));
	case 2: return x2 * ATanRad((float)(2 * x + 1));
	case 3: return SinRad(CosRad(Abs(x)));
	default: std::exit(-1);
	}
}

void InitFxTable(double** Arr, int rows, double a, double h) {
	// Цель: Инициализация двумерного массива значениями x и f(x)
	// Исходные данные:
	//		Arr – указатель на инициализируемый двумерный динамический массив
	//		rows - количество строк в массиве
	//		а - текущее значение х, в начале соответствует левой границе полуинтервала [a, b)
	//		h - шаг дискретизации х
	// Результат: Массив инициализирован соответствующими значениями x и f(x)
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 2) Выполняется проход по строкам двумерного массива с помощью временной переменной i
	* 3) В нулевой столбец записывается текущее значение переменной а (соответствует значению х)
	* 4) В первый столбец записывается результат вычисления значения f(x)
	* 5) Текущее значение а увеличивается на размер шага согласно условия задачи*/
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	for (int i = 0; i < rows; i++) {
		Arr[i][0] = a;
		Arr[i][1] = Fx(a);
		a += h;
	}
}

double FxTableMax(double** Arr, int rows) {
	// Цель: Поиск максимального по модулю значения f(x) в таблице
	// Исходные данные:
	//		Arr – указатель на двумерный динамический массив, содержащий соответствующие значения таблицы
	//		rows - количество строк в массиве
	// Результат: Функция возвращает максимальное по модулю значение f(x) в таблице
	// Вызываемые модули: "my_math.h"
	/* Описание алгоритма :
	* 1) Объявляется переменная max типа double и инициализируется первым значением f(x)
	в таблице
	* 2) Выполняется проход по строкам двумерного массива с помощью временной переменной i,
	* которая принимает значения от 1 до rows - 1, т.к. значение нулевой строки уже сохранено
	в переменной max;
	* 3) Для каждой итерации сравнивается модуль значения переменной max и соответствующий строке
	модуль значения f(x). Если значение модуля f(x) больше, то само значение присваивается переменной max;
	* 4) По завершению цикла функция возвращает значение переменной max типа double,
	* которое и является максимальным по модулю значением f(x) в таблице
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/******************************************************************************************************/
	double max = Arr[0][1]; // объявляется переменная max типа double и инициализируется первым
	// значением f(x) в таблице
	for (int i = 1; i < rows; i++) {
		if (Abs(Arr[i][1]) > Abs(max)) max = Arr[i][1];// обновление переменной max, в случае обнаружения
		// максимального по модулю значения
	}
	return max; // возврат наибольшего по модулю значения f(x) в таблице
}

void PrintFxTable(double** Arr, int rows) {
	// Цель: Вывод на консоль таблицы значений х и Y(x)
	// Исходные данные:
	//		Arr – указатель на двумерный массив, содержащий соответствующие значения таблицы
	//		rows - количество строк в массиве
	// Результат: Таблица значений х и Y(x) выведена на консоль
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) С помощью форматного вывода printf выводим на консоль обозначения будущих значений,
	* имеющих вид |порядковый номер в таблице|f(x)| x|
	* 2) Выполняется проход по строкам двумерного массива с помощью временной переменной i
	* 3) С помощью форматного вывода printf выводим на консоль порядковый номер в таблице,
	* значение f(x) и значение x */
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/

	/*Вывод обозначений*/
	printf("\n |%3c| %10c | %8c|\n%s\n", '№', 'F', 'X', "----------------------------");
	for (int i = 0; i < rows; i++) {
		/*Вывод значений*/
		printf(" |%3d| %10lf | %8.3lf|\n", i + 1, Arr[i][1], Arr[i][0]);
	}
}

int Menu() { 
	// Цель: Вывод на консоль текста меню и ввод корректного выбора
	// Исходные данные:
	// Результат: Функция возвращает целое значение, соответствующее выбору пользователя
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) С помощью форматного вывода printf выводим на консоль запрос на ввод целого числа,
	* соответствующего нужной операции
	* 2) Выполняется ввод с клавиатуры нужного пункта меню
	* 3) Выполняется проверка наличия введенного пункта в меню
	* 4) Возвращается целое значение, соответствующее пункту меню
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	printf("\n **********************************************\n\
 * Выберете способ подготовки данных:         *\n\
 * 1 - «автоматическая» программная генерация *\n\
 * 2 - ручной ввод                            *\n\
 * 3 - завершить работу программы             *\n\
 **********************************************\n");
	/* проверка корректности ввода на основе CorrectInit()*/
	int k{-1};
	printf(" Ваш выбор: ");
	int correct_in = scanf_s("%d", &k);
	while (correct_in != 1 || k < 1 || k>3) {
		scanf_s("%*[^\n]"); // Очистка буфера ввода
		printf(" Неверный выбор! Повторите ввод: ");
		correct_in = scanf_s("%d", &k);
	}
	printf("\n");
	return k;
}

void CorrectInit(double& x) {
	// Цель: Инициализация переменной корректным значением
	// Исходные данные:
	//	x – ссылка на переменную
	// Результат: функция ничего не возвращает, переменной присвоено 
	// корректное значение по соответствующей ссылке
	// Вызываемые модули: нет
	/* Описание алгоритма :
	В функции создается бесконечный цикл, продолжающийся, пока
	корректное значение не будет введено.
	1) Объявляется временная переменная tmp типа char;
	2) На консоль выводится приглашение ввести значение переменной,
	при этом указывается, что переменная должна быть вещественным числом.
	3) Пользователь вводит значение, которое присваивается соответствующей
	переменной по ссылке. При этом инициализируется переменная correct_in которой
	присваивается значение, возвращаемое функцией scanf_s.
	Правильный ввод	вещественного числа должен быть выполнен с использованием
	запятой(',') в качестве	разделителя дробной и целой части.
	В случае, когда пользователь использует точку ('.') в качестве разделителя,
	переменной x будет присвоена лишь целая	часть желаемого числа, а первый символ
	дробной части присвоится временной переменной tmp.
	4) Производится очистка буфера потока ввода. Это необходимо для того
	чтобы избежать ошибочного считывания данных из буфера при следующей
	итерации в случае неверного ввода. К примеру, без очистки буфера, в
	случае ввода литерала получим бесконечный цикл.
	5) Проверка корректности введенного значения:
	Так как функция scanf_s возвращает значение, равное количеству успешно
	считанных данных, переменная correct_in будет содержать информацию о том, была ли
	инициализирована переменная x корректно.
	- если значение correct_in не равно 1, то переменная х может быть не инициализирована,
	либо инициализирована не верно в случае ввода с точкой в качестве разделителя.
	В таком случае на консоль выводится сообщение об ошибке, затем цикл повторяется;
	- иначе прерываем цикл иструкцией break. */
	// Дата: 2022 / 01 / 15 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/***********************************************************************/

	/* Ввод переменной x */
	char tmp; // объявление временной переменной типа char
	while (true) {
		/* введенное значение присваивается переменной x по ссылке
		correct_in инициализируется значением, возвращенным scanf_s
		если разделитель точка, временной переменной tmp присвоится первый символ после точки */
		int correct_in = scanf_s("%lf.%c", &x, &tmp, (unsigned int)sizeof(tmp));
		scanf_s("%*[^\n]"); // Очистка буфера ввода

		/* Проверка корректности введенного значения */
		if (correct_in == 0) { // если переменная не инициализирована
			printf_s(" Ошибка ввода – неверное значение переменной!\n Ввод: ");
		}
		else if (correct_in > 1) { // если в при вводе инициализирована переменная tmp
			printf_s(" Ошибка ввода - используйте запятую в качестве разделителя\n Ввод: ");
		}
		else break;
	}
}

void HandInput(double& a, double& b, double& h) {
	// Цель: Ввод с клавиатуры корректных значений для границ диапазона и шага дисретизации х
	// Исходные данные:
	//		&a - ссылка на переменную, соответствующую левой границе полуинтервала [a, b)
	//		&b - ссылка на переменную, соответствующую левой границе полуинтервала [a, b)
	//		&h - ссылка на переменную, соответствующую шагу дискретизации х
	// Результат: целевые переменные инициализированы корректными значениями, введенными 
	// пользователем с клавиатуры.
	// Вызываемые модули: CorrectInit()
	/* Описание алгоритма :
	* 1) С помощью форматного вывода printf выводим на консоль запрос на ввод вещественного числа,
	* соответствующего переменной а
	* 2) Выполняется ввод с клавиатуры нужного значения
	* 3) Вызывается функция CorrectInit() для проверки корректности введенного значения
	* 4) Пункты 1-3 повторяются для переменной b
	* 5) Выполняется проверка соответствия введенного значения условию b < a
	* 6) Пункты 1-3 повторяются для переменной h
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	printf(" Введите вещественное значение ""a"" для Х из полуинтервала [a; b)\n Ввод: ");
	CorrectInit(a);
	printf("\n Введите вещественное значение ""b"" для Х из полуинтервала [a; b)\n Ввод: ");
	CorrectInit(b);
	while (b <= a) {
		printf(" Не верная граница полуинтервала, повторите ввод b\n Ввод: ");
		CorrectInit(b);
	}
	printf("\n Введите вещественное значение ""h"", соответствующее шагу дискретизации Х\n Ввод: ");
	CorrectInit(h);
}

void RandomInput(double& a, double& b, double& h) {
	// Цель: Инициализация псевдо-случайными числами переменных, соответствующих границам 
	// полуинтервала и шагу дискретизации х
	// Исходные данные:
	//		&a - ссылка на переменную, соответствующую левой границе полуинтервала [a, b)
	//		&b - ссылка на переменную, соответствующую левой границе полуинтервала [a, b)
	//		&h - ссылка на переменную, соответствующую шагу дискретизации х
	// Результат: целевые переменные инициализированы псевдо-случайными значениями
	// Вызываемые модули: MyRand()
	/* Описание алгоритма :
	* 1) Переменная а инициализируется отрицательным значением для обеспечения условия a < b
	* значение а вещественное и имеет 3 знака после точки
	* 2) Переменная b инициализируется положительным значением для обеспечения условия a < b
	* значение b вещественное и имеет 3 знака после точки
	* 3) Переменная h инициализируется положительным значением на разряд меньше a и b.
	* Значение h вещественное и имеет 3 знака после точки
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/***************************************************************************************/

	a = -MyRand() / 1000.; // a - вещественное ПСЧ в диапазоне [-32.767, 0.000]
	b = MyRand() / 1000.; // b - вещественное ПСЧ в диапазоне [0.000, 32.767]
	h = MyRand() % 5000 / 1000.; // h - вещественное ПСЧ в диапазоне[1.000, 9.999]
}

int MyRand(){
	// Цель: Генерация псевдо-случайных чисел с помощью алгоритма линейного конгруэнтного
	// генератора (ЛКГ)
	// Исходные данные:
	// Результат: функция возврачает псевдо-случайное число из равномерно распределенного интервала
	// 0 - 32760
	/* Описание алгоритма :
	* 1) Переменная а инициализируется отрицательным значением для обеспечения условия a < b
	* значение а вещественное и имеет 3 знака после точки
	* 2) Переменная b инициализируется положительным значением для обеспечения условия a < b
	* значение b вещественное и имеет 3 знака после точки
	* 3) Переменная h инициализируется положительным значением.
	* Значение h вещественное и имеет 3 знака после точки
	// Дата: 2022 / 01 / 26 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	static unsigned long int next = (unsigned long)time(0);
	next = next * 1103515245 + 12345;
	return (unsigned int)(next / 65536) % 32768;
}

// функция вызова исключения связанного с выделением памяти для передачи в set_new_handler()
void __cdecl new_error() {
	throw std::bad_alloc();
	return;
}
